---
# Python  
---
*edited: Friday, Oct 28th*
## Automating the boring stuff
### Chapter 1: Python programming basics
**Expression vs statement**: an expression is a combination of values and operators. All expressions evaluate (i.e. reduce) to a single value, statements do not.
### Chapter 2: Flow control
**Condition**: A condition is an expression used in a flow control statement that evaluates to a Boolean value.  
**Break vs continue statements**: The break statement will move the execution outside and just after a loop. The continue statement will move the execution to the start of the loop.
### Chapter 3: Functions
The data type of `None` is `NoneType`.  
Can use the `global` statement to modify a global variable from within a function. eg:
```
def spam()
  global eggs
  eggs = 'spam'

eggs = 'global'
spam()
print(eggs)
```
Output: `spam`  
Exception handling: to avoid program crash from errors/exceptions, do `try` and `except` clauses. Eg: `except ZeroDivisionError`

### Chapter 4: Lists
NB: slice of a list will include the first item, but will go up (not including) the second item. `spam[1:3]` grabs `spam[1]` and `spam[2]`.  
Multiple assignment trick: can assign a list as a value for three variables. Make sure to have the same number of variables and items in the list or you'll get a `ValueError`
```
cat = [tuxedo, tabby, Sphynx]
Twist, Daisy, Ramses = cat
```
**Method vs function**: method is same as a function, except it is "called on" a value. Difference between `cat.index(tuxedo)` vs `print(cat[0])`  
Modify lists *in place* with `myList.insert(index, itemToInsert)` and `myList.append(itemToInsert)`.  
Can also remove items with `myList.remove(itemToRemove)`  
**List-like data types**: strings and tuples. 
- String vs list: a list is a **mutable** data type and strings are basically lists of characters.
- Tuples vs lists: Tuples are types with parentheses, Also, tuples cannot have their values modified/appended/removed. Finally, using tuples is slightly faster.

**âš References**: be careful when making a copy of a list, because modifying either list will affect the other. **When you assign a list to a variable, you are actually assigning a list reference to the variable.** Essentially, when copying a list, they both point to the same sequence of values. eg:
```
cats = ["tuxedo", "tabby", "Sphynx"]

catsCopy = cats

catsCopy
Out[4]: ['tuxedo', 'tabby', 'Sphynx']

cats[1] = "orange"

catsCopy
Out[6]: ['tuxedo', 'orange', 'Sphynx']
```
To avoid modifying the original list or dictionary, you can use the module `copy` which includes functions `copy()` and `deepcopy()` (the latter is used for embedded lists).

> "The del statement is good to use when you know the index of the value
you want to remove from the list. The remove() method is good when you
know the value you want to remove from the list." (p. 91)

### Chapter 5: Dictionaries and Structuring Data

`keys(), values(), items()`: values returned are not true lists but they can be used in `for` loops. NB: values returned by `items()` method are tuples.  
Can use get() method on dictionary to retrieve value based on key. get() takes two arguments: the key you are searching for, and a default value if the key doesn't exist.  
Use `setdefault` to create a key value if the key does not exist already. If it does exist, it will return the current value. Can use it to create a character counter for example:
```
count = {}
string = "foo bar baz"
for character in message:
    count.setdefault('character', 0)
	count[character] += 1
``` 

Can pretty print a dictionary to make it easier to read using `pprint` and `pformat`

### Chapter 6: Manipulating Strings
Use raw strings to enable the use of *escape characters* (`\`, `\t`, `\n`, `"`, `'`). eg: `r"This is a raw string so I can use \"`  

**String methods**:
- methods to convert: `upper()`, `lower()`
- `is` methods to check content of string: `isupper()`, `islower()`, `isalpha()`, `isalnum()`, `isdecimal()`, `isspace()`, `istitle()`
- `join()` and `split()` (NB: `join` follows the separator eg `' '.join(listOfStrings)`, while `split` follows the string you are splitting eg `"My name is Ben".split()`)
- Can justify text to the left, right, or center: `ljust()`, `rjust()`, `center()`. Can be useful to output item lists/receipts.
- remove whitespace with `strip()`, `rstrip()` and `lstrip()`. Whitespace by default but can choose any characters to strip - order doesn't matter i.e. `myString.strip('Spam')` is equivalent to `myString.strip('ampS')`.
- Can import the module **`pyperclip`** (doesn't come by default) to copy and paste things to the clipboard: `pyperclip.copy(myString)`, `pyperclip.paste()`.

### Chapter 7: Pattern Matching with Regular Expressions
Can pass a raw string regex pattern to a `re.compile` object. Will return a **regex pattern object**.
```
phoneNumberRegex = re.compile(r'\d{3}-\d{3}-\d{4}')
```
- if want to capture newline character (`\n`), provide `re.compile()` the argument `re.DOTALL`
- if you want to ignore case, provide the argument `re.I`
- if you want to provide a multi-line regex pattern, provide argument `re.VERBOSE`

Can combine the arguments using a *bitwise operator* `|`:
```
someRegexValue = re.compile('foo', re.I | re.DOTALL | re.VERBOSE)
```
**N.B.** for complex regex searches use `VERBOSE` and comments:
```
phoneRegex = re.compile(r'''(
	(\d{3}|\(\d{3}\))?		# area code
	(\s|-|\.)? 			# separator
	\d{3} 				# first 3 digits
	(\s|-|\.) 			# separator
	\d{4} 				# last 4 digits
	(\s*(ext|x|ext.)\s*\d{2,5})?	# extension
	)''', re.VERBOSE)
```

Use `.search()` method on the regex object and pass a string value to find matches. NB search returns the first result. If you want to find all matches, use `findall()`.
```
matchObject = phoneNumberRegex.search("My number is 415-555-4242.")
```
If a match is found, can output the matched sub-string with `.group()`:
```
matchObject.group()
```
If you are using capture groups `()` in your regex pattern, `.group()` can return either the entire match with `.group()` or `.group(0)`, or your capture group `.group(1)`.
```
>>> regexPattern = re.compile(r'(\d{3})-(\d{3}-\d{4})')
>>> phoneNumberMatch = regexPattern.search("202-805-8085")
>>> phoneNumberMatch.group()
'202-805-8085'
>>> phoneNumberMatch.group(1)
'202'
```
The `findall()` method returns a list of strings with every match in the searched string. **N.B.** if you use the `.findall()` method with capture groups, it will return a list of tuples of strings.
```
>>> regexPattern = re.compile(r'(\d{3})-(\d{3}-\d{4})')
>>> phoneNumberMatch = regexPattern.search("Call is 202-805-8085, home is 212-628-7724")
>>> phoneNumberMatch.group()
'202-805-8085'
>>> phoneNumberMatch.group(1)
'202'
>>> phoneNumberMatch.group(2)
'805-8085'
>>> AllPhoneNumberFound = regexPattern.findall("Cell is 202-805-8085, home is 212-628-7724")
>>> AllPhoneNumberFound
[('202', '805-8085'), ('212', '628-7724')]
>>> regexPatternNoGroup = re.compile(r'\d{3}-\d{3}-\d{4}')
>>> AllPhoneNumberFoundNoGroup = regexPatternNoGroup.findall("Cell is 202-805-8085, home is 212-628-7724")
>>> AllPhoneNumberFoundNoGroup
['202-805-8085', '212-628-7724']
```
**Regex Character Classes:**

shorthand | represents
-|-
\d | digits from 0 to 9
\w | all word characters (letters, digits, underscore)
\s | space, tab, ot newline character

Make your own character class: 
```
vowelRegex = re.compile(r'[AEIOUaeiou]')
```
**substitute strings** using the `.sub()` method.
```
>>> agentNameRegex = re.compile(r'Agent \w+')
>>> agentNameRegex.sub("CENSORED", "Agent Ben gave Agent Marina a very important loaf of bread")
'CENSORED gave CENSORED a very important loaf of bread'
```
Your wildcard `.*` can be greedy and will match as much as possible, or **non-greedy** and match the shortest string `.*?`.

Lookahead: `(?=foo)`
Negative lookbehind: `(?<!foo)`
- **N.B.** Negative lookbehind can be concatenated.  
```
nameMatchObject = re.compile(r'(?<!^)(?<!! )[A-Z][a-z]+')
```
> *searching for a name, can use negative lookbehind to exclude both beginning of line and previous punctuation*